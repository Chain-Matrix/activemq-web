<div class="wiki-content maincontent"><p>The thing to remember is JmsTemplate is designed for use in EJBs using the EJB containers JMS pooling abstraction. So every method will typically create a connection, session, producer or consumer, do something, then close them all down again. The idea being that this will use the J2EE containers pooling mechanism to pool the JMS resources under the covers. Without using a pooled JMS provider from the EJB container this is the worst possible way of working with JMS; since typically each create/close of a connection, producer/consumer results in a request-response with the JMS broker.</p>

<structured-macro ac:macro-id="b1b7138d-6479-4785-b123-cb2f14d691e6" ac:name="info" ac:schema-version="1"><parameter ac:name="title">User Story</parameter><rich-text-body>
<p>We had a bug once in ActiveMQ where if you created 65535 MessageProducer instances within the space of a few seconds, we'd get an exception thrown in the broker. Its a kinda silly thing to do, to create that many producers in a small space of time (one for each message to be sent) - JMS is designed for resources like producers and consumers to be created up front and reused across many message exchanges. The bug was highlighted by a user using JmsTemplate without a JMS pool underneath. Well at least it helped find our bug which I'm glad to say is now fixed, but it didn't help their performance too much <emoticon ac:name="smile"></emoticon></p></rich-text-body></structured-macro>

<p>You should only use JmsTemplate with a pooled JMS provider. In J2EE 1.4 or later that typically means a JCA based JMS ConnectionFactory. If you are in an EJB then make sure you use your J2EE containers ConnectionFactory, never a plain-old-connection factory. If you are not inside an EJB Then you should use our <a shape="rect" href="http://activemq.apache.org/maven/activemq-core/apidocs/org/apache/activemq/pool/PooledConnectionFactory.html">PooledConnectionFactory</a>, then things will be nicely pooled. If you need to take part in XA transactions then look into our spring based <link><page ri:content-title="JCA Container"></page></link>.</p>

<p>Another gotcha I've seen folks do is to create a MessageConsumer inside one of the SessionCallback methods then wonder why messages are not being received. After the SessionCallback is called, the session will be closed; which will close your consumers too <emoticon ac:name="smile"></emoticon>. So if you want to create a MessageConsumer you should create a connection, session and consumer yourself.</p>

<p>Another problem I've seen is folks using the JmsTemplate.receive() method; as I've said above if you're not in an EJB using the J2EE containers ConnnectionFactory, a connection, session &amp; consumer will be create and closed for each receive() method. This is all fine and well - if painfully slow unless you are using pooling - but be aware that this mechanism, without pooling, may well miss messages. If you are consuming on a topic which has messages sent with NON_PERSISTENT delivery mode then chances are you will miss messages, since each receive() call is a brand new consumer which will not receive any messages sent before the consumer existed. To receive messages efficiently you should use Spring's <a shape="rect" href="http://static.springsource.org/spring/docs/2.5.x/reference/jms.html#jms-mdp">MessageListenerContainer</a>.</p>

<structured-macro ac:macro-id="c93967d2-f5ce-4be6-8fa0-91d117d43290" ac:name="info" ac:schema-version="1"><parameter ac:name="title">New in 4.x</parameter><rich-text-body>
<p>In ActiveMQ <link><page ri:content-title="Changes in 4.0"></page><link-body>4.x</link-body></link> we have a new feature called <link><page ri:content-title="Subscription Recovery Policy"></page></link> which even in non-durable delivery mode allows a new consumer to go back in time and receive messages delivered within a window (a fixed amount of RAM or time window). e.g. if your broker dies you have 2 minutes to reconnect to another broker and not miss any messages - even without durable delivery.</p></rich-text-body></structured-macro>

<h3>Recommendations for using JmsTemplate</h3>

<ul><li>Never use a regular ConnectionFactory unless you are totally sure it does all the pooling you need</li><li>If using in an EJB ensure you use the EJB containers ConnectionFactory</li><li>If you are only publishing messages and you are not in an EJB container and you are using ActiveMQ, then you can use either the <a shape="rect" href="http://activemq.codehaus.org/maven/apidocs/org/activemq/pool/PooledConnectionFactory.html">PooledConnectionFactory</a> or the <a shape="rect" href="http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/jms/connection/CachingConnectionFactory.html">Spring CachingConnectionFactory</a></li><li>If you are consuming messages its probably simpler &amp; more efficient &amp; less likely to lose messages to avoid using the receive() method and use Spring's <a shape="rect" href="http://static.springsource.org/spring/docs/2.5.x/reference/jms.html#jms-mdp">MessageListenerContainer</a> instead</li><li>See also <a shape="rect" href="http://bsnyderblog.blogspot.com/2010/02/using-spring-jmstemplate-to-send-jms.html">Using Spring to Send JMS Messages</a> and <a shape="rect" href="http://bsnyderblog.blogspot.com/2010/02/using-spring-to-receive-jms-messages.html">Using Spring to Receive JMS Messages</a></li></ul>
</div>

