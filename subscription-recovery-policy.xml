<div class="wiki-content maincontent"><p>The subscription recovery policy allows you to go back in time when you subscribe to a topic.</p><p>For example imagine you are processing a price feed; you're using a federated network and either a network glitch occurs or someone kills the broker you're talking to. If you reconnect to another broker in the cluster you may have lost messages.</p><p>So we support a timed or fixed size recovery buffer so that if you reconnect to another broker within some time period (depending on volume &amp; RAM this could be 30 seconds to 5 minutes), then any messages you missed during the downtime are redelivered before new messages are delivered to you.</p><p>For more information see <a shape="rect" href="retroactive-consumer.xml">Retroactive Consumer</a></p><h3 id="SubscriptionRecoveryPolicy-Lastimagecaching">Last image caching</h3><p>Its often common in financial market data type worlds to want to know the latest price of say IBM stock along with get all the future updates to the price. Historically you often had a request-reply snapshot quote service for the latest price, then you subscribe to a topic for updates. The issue is the client then has 2 APIs / middlewares to deal with - often quite different things - plus you have an ordering issue (race condition) - the update could beat the last price request so you can get out of order (going back in time to an old price, which could be very old).</p><p>One of our <em>subscription recovery policy</em> implementations is called <strong>Last Image Subscription Policy</strong> which will ensure that when you subscribe to a topic (say PRICES.NASDAQ.IBM), you will receive the last image (the last message that was sent on that topic) plus any updates which occur in the future, with ordering to ensure that the last image is always first before any new messages arrive.</p><p>A common problem in market data type situations is that you may have a cache of last image prices, then a feed of new price changes; if you request the last price from the cache and subscribe to new prices; depending on how you do it you can either, miss an update or receive a newer update before the old last image arrives (so either get out of order messages).</p><p>Note that you can configure the subscription recovery policy, and most other policies on different destinations or wildcards. So you may use last image policy for prices on topics only and use a buffered fixed size policy for other notifications on different topics etc.</p><h3 id="SubscriptionRecoveryPolicy-SummaryofAvailableRecoveryPolicies">Summary of Available Recovery Policies</h3><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Policy Name</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Sample Configuration</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>FixedSizedSubscriptionRecoveryPolicy</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&lt;fixedSizedSubscriptionRecoveryPolicy maximumSize="1024"/&gt;</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Keep a fixed amount of memory in RAM for message history which is evicted in time order.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>FixedCountSubscriptionRecoveryPolicy</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&lt;fixedCountSubscriptionRecoveryPolicy maximumSize="100"/&gt;</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Keep a fixed count of last messages.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>LastImageSubscriptionRecoveryPolicy</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&lt;lastImageSubscriptionRecoveryPolicy/&gt;</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Keep only the last message.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>NoSubscriptionRecoveryPolicy</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&lt;noSubscriptionRecoveryPolicy/&gt;</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Disables message recovery.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>QueryBasedSubscriptionRecoveryPolicy</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&lt;queryBasedSubscriptionRecoveryPolicy query="JMSType = 'car' AND color = 'blue'"/&gt;</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Perform a user specific query mechanism to load any message they may have missed. Details on message selectors are available here:</p><a shape="rect" class="external-link" href="http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html" rel="nofollow">http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html</a><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>TimedSubscriptionRecoveryPolicy</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&lt;timedSubscriptionRecoveryPolicy recoverDuration="60000" /&gt;</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Keep a timed buffer of messages around in memory and use that to recover new subscriptions. Recovery time is in milliseconds.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">RetainedMessageSubscriptionRecoveryPolicy</td><td colspan="1" rowspan="1" class="confluenceTd">&lt;r<span>etainedMessageSubscriptionRecoveryPolicy/&gt;</span></td><td colspan="1" rowspan="1" class="confluenceTd">Keep the last message with ActiveMQ.Retain property set to true</td></tr></tbody></table></div></div>

