<div class="wiki-content maincontent"><h2>Configuring NMS.ActiveMQ</h2><p>All configuration is achieved via URI-encoded parameters, either on the connection or destinations. Through the URIs, you can configure virtually every facet of your NMS.ActiveMQ client. The tables below show the comprehensive set of parameters.</p><h3><strong>Connection URI Parameters</strong></h3><h5>&#160;Example Configuration</h5><p>Using the Generic NMSConnectionFactory class would look as follows:</p><structured-macro ac:macro-id="e1f01dc1-8328-4511-ad26-deef9612f4ed" ac:name="noformat" ac:schema-version="1"><plain-text-body>var cf = new NMSConnectionFactory(
    "activemq:tcp://localhost:61616?wireFormat.tightEncodingEnabled=true");
</plain-text-body></structured-macro><p>You can also use the ActiveMQ ConecctionFactory implementation directory:</p><structured-macro ac:macro-id="0ca94639-950e-4d60-9fac-b15b45b5731e" ac:name="noformat" ac:schema-version="1"><plain-text-body>var cf = new Apache.NMS.ActiveMQ.ConnectionFactory(
    "tcp://localhost:61616?wireFormat.tightEncodingEnabled=true");
</plain-text-body></structured-macro><h3>Protocol Options</h3><table><tbody><tr><th colspan="1" rowspan="1"><p>Option Name</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>tcp</p></td><td colspan="1" rowspan="1"><p>Uses TCP/IP Sockets to connect to the Broker.</p></td></tr><tr><td colspan="1" rowspan="1"><p>ssl</p></td><td colspan="1" rowspan="1"><p>Uses TCP/IP Sockets to connect to the Broker with an added SSL layer.</p></td></tr><tr><td colspan="1" rowspan="1"><p>discovery</p></td><td colspan="1" rowspan="1"><p>Uses The Discovery Transport to find a Broker</p></td></tr><tr><td colspan="1" rowspan="1"><p>failover</p></td><td colspan="1" rowspan="1"><p>Uses the Failover Transport to connect and reconnect to one or more Brokers</p></td></tr></tbody></table><h4><strong>Transport Options</strong></h4><h5><strong>TCP Transport Options</strong></h5><table><tbody><tr><th colspan="1" rowspan="1"><p>Option Name</p></th><th colspan="1" rowspan="1"><p>Default</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>transport.useLogging</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Log data that is sent across the Transport.</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.receiveBufferSize</p></td><td colspan="1" rowspan="1"><p>8192</p></td><td colspan="1" rowspan="1"><p>Amount of Data to buffer from the Socket</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.sendBufferSize</p></td><td colspan="1" rowspan="1"><p>8192</p></td><td colspan="1" rowspan="1"><p>Amount of Data to buffer before writing to the Socket</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.receiveTimeout</p></td><td colspan="1" rowspan="1"><p>0</p></td><td colspan="1" rowspan="1"><p>Time to wait for more data, zero means wait infinitely</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.sendTimeout</p></td><td colspan="1" rowspan="1"><p>0</p></td><td colspan="1" rowspan="1"><p>Timeout on sends, 0 means wait forever for completion</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.requestTimeout</p></td><td colspan="1" rowspan="1"><p>0</p></td><td colspan="1" rowspan="1"><p>Time to wait before a Request Command is considered to have failed</p></td></tr></tbody></table><h5>Discovery Transport Options</h5><h5>Failover Transport Options</h5><p>Prior to NMS.ActiveMQ v1.4.0 the failover transport options did not use the transport.* prefix.</p><table><tbody><tr><th colspan="1" rowspan="1"><p>Option Name</p></th><th colspan="1" rowspan="1"><p>Default</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>transport.timeout</p></td><td colspan="1" rowspan="1"><p>-1</p></td><td colspan="1" rowspan="1"><p>Time that a send operation blocks before failing.</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.initialReconnectDelay</p></td><td colspan="1" rowspan="1"><p>10</p></td><td colspan="1" rowspan="1"><p>Time in Milliseconds that the transport waits before attempting to reconnect the first time.</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.maxReconnectDelay</p></td><td colspan="1" rowspan="1"><p>30000</p></td><td colspan="1" rowspan="1"><p>The max time in Milliseconds that the transport will wait before attempting to reconnect.</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.backOffMultiplier</p></td><td colspan="1" rowspan="1"><p>2</p></td><td colspan="1" rowspan="1"><p>The amount by which the reconnect delay will be multiplied by if useExponentialBackOff is enabled.</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.useExponentialBackOff</p></td><td colspan="1" rowspan="1"><p>true</p></td><td colspan="1" rowspan="1"><p>Should the delay between connection attempt grow on each try up to the max reconnect delay.</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.randomize</p></td><td colspan="1" rowspan="1"><p>true</p></td><td colspan="1" rowspan="1"><p>Should the Uri to connect to be chosen at random from the list of available Uris.</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.maxReconnectAttempts</p></td><td colspan="1" rowspan="1"><p>0</p></td><td colspan="1" rowspan="1"><p>Maximum number of time the transport will attempt to reconnect before failing (0 means infinite retries)</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.startupMaxReconnectAttempts</p></td><td colspan="1" rowspan="1"><p>0</p></td><td colspan="1" rowspan="1"><p>Maximum number of time the transport will attempt to reconnect before failing when there has never been a connection made. (0 means infinite retries) <strong>(included in NMS.ActiveMQ v1.5.0+)</strong></p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.reconnectDelay</p></td><td colspan="1" rowspan="1"><p>10</p></td><td colspan="1" rowspan="1"><p>The delay in milliseconds that the transport waits before attempting a reconnection.</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.backup</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Should the Failover transport maintain hot backups.</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.backupPoolSize</p></td><td colspan="1" rowspan="1"><p>1</p></td><td colspan="1" rowspan="1"><p>If enabled, how many hot backup connections are made.</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.trackMessages</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>keep a cache of in-flight messages that will flushed to a broker on reconnect</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.maxCacheSize</p></td><td colspan="1" rowspan="1"><p>256</p></td><td colspan="1" rowspan="1"><p>Number of messages that are cached if trackMessages is enabled.</p></td></tr><tr><td colspan="1" rowspan="1"><p>transport.updateURIsSupported</p></td><td colspan="1" rowspan="1"><p>true</p></td><td colspan="1" rowspan="1"><p>Update the list of known brokers based on BrokerInfo messages sent to the client.</p></td></tr></tbody></table><h4><strong>Connection Options</strong></h4><p>Connection options can either be set via the connection.* prefix or the nms.* prefix similar to the java client's jms.* prefix settings.</p><table><tbody><tr><th colspan="1" rowspan="1"><p>Option Name</p></th><th colspan="1" rowspan="1"><p>Default</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>connection.AsyncSend</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Are message sent Asynchronously.</p></td></tr><tr><td colspan="1" rowspan="1"><p>connection.AsyncClose</p></td><td colspan="1" rowspan="1"><p>true</p></td><td colspan="1" rowspan="1"><p>Should the close command be sent Asynchronously</p></td></tr><tr><td colspan="1" rowspan="1"><p>connection.AlwaysSyncSend</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Causes all messages a Producer sends to be sent Asynchronously.</p></td></tr><tr><td colspan="1" rowspan="1"><p>connection.CopyMessageOnSend</p></td><td colspan="1" rowspan="1"><p>true</p></td><td colspan="1" rowspan="1"><p>Copies the Message objects a Producer sends so that the client can reuse Message objects without affecting an in-flight message.</p></td></tr><tr><td colspan="1" rowspan="1"><p>connection.ProducerWindowSize</p></td><td colspan="1" rowspan="1"><p>0</p></td><td colspan="1" rowspan="1"><p>The ProducerWindowSize is the maximum number of bytes in memory that a producer will transmit to a broker before waiting for acknowledgement messages from the broker that it has accepted the previously sent messages. In other words, this how you configure the producer flow control window that is used for async sends where the client is responsible for managing memory usage. The default value of 0 means no flow control at the client. See also <a shape="rect" href="http://activemq.apache.org/producer-flow-control.html">Producer Flow Control</a></p></td></tr><tr><td colspan="1" rowspan="1"><p>connection.useCompression</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Should message bodies be compressed before being sent.</p></td></tr><tr><td colspan="1" rowspan="1"><p>connection.sendAcksAsync</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Should message acks be sent asynchronously</p></td></tr><tr><td colspan="1" rowspan="1"><p>connection.messagePrioritySupported</p></td><td colspan="1" rowspan="1"><p>true</p></td><td colspan="1" rowspan="1"><p>Should messages be delivered to the client based on the value of the Message Priority header.</p></td></tr><tr><td colspan="1" rowspan="1"><p>connection.dispatchAsync</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Should the broker <a shape="rect" href="http://activemq.apache.org/consumer-dispatch-async.html">dispatch messages asynchronously</a> to the connection's consumers.</p></td></tr><tr><td colspan="1" rowspan="1"><p>connection.watchTopicAdvisories</p></td><td colspan="1" rowspan="1"><p>true</p></td><td colspan="1" rowspan="1"><p>Should the client watch for advisory messages from the broker to track the creation and deletion of temporary destinations.</p></td></tr></tbody></table><h5><strong>OpenWire Options</strong></h5><table><tbody><tr><th colspan="1" rowspan="1"><p>Option Name</p></th><th colspan="1" rowspan="1"><p>Default</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>wireFormat.stackTraceEnabled</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Should the stack trace of exception that occur on the broker be sent to the client? Only used by openwire protocol.</p></td></tr><tr><td colspan="1" rowspan="1"><p>wireFormat.cacheEnabled</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Should commonly repeated values be cached so that less marshalling occurs? Only used by openwire protocol.</p></td></tr><tr><td colspan="1" rowspan="1"><p>wireFormat.tcpNoDelayEnabled</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Does not affect the wire format, but provides a hint to the peer that TCP nodelay should be enabled on the communications Socket. Only used by openwire protocol.</p></td></tr><tr><td colspan="1" rowspan="1"><p>wireFormat.sizePrefixDisabled</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Should serialized messages include a payload length prefix? Only used by openwire protocol.</p></td></tr><tr><td colspan="1" rowspan="1"><p>wireFormat.tightEncodingEnabled</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Should wire size be optimized over CPU usage? Only used by the openwire protocol.</p></td></tr><tr><td colspan="1" rowspan="1"><p>wireFormat.maxInactivityDuration</p></td><td colspan="1" rowspan="1"><p>30000</p></td><td colspan="1" rowspan="1"><p>The maximum inactivity duration (before which the socket is considered dead) in milliseconds. On some platforms it can take a long time for a socket to appear to die, so we allow the broker to kill connections if they are inactive for a period of time. Use by some transports to enable a keep alive heart beat feature. Set to a value &lt;= 0 to disable inactivity monitoring.</p></td></tr><tr><td colspan="1" rowspan="1"><p>maxInactivityDurationInitalDelay</p></td><td colspan="1" rowspan="1"><p>10000</p></td><td colspan="1" rowspan="1"><p>The initial delay in starting the maximum inactivity checks (and, yes, the word 'Inital' is supposed to be misspelled like that)</p></td></tr></tbody></table><h3><strong>Destination URI Parameters</strong></h3><h5>Example Configuration</h5><structured-macro ac:macro-id="f2b94df0-4839-4b0f-ab6f-365c063fba47" ac:name="noformat" ac:schema-version="1"><plain-text-body>d = session.CreateTopic("com.foo?consumer.prefetchSize=2000&amp;consumer.noLocal=true");
</plain-text-body></structured-macro><h4><strong>General Options</strong></h4><table><tbody><tr><th colspan="1" rowspan="1"><p>Option Name</p></th><th colspan="1" rowspan="1"><p>Default</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>consumer.prefetchSize</p></td><td colspan="1" rowspan="1"><p>1000</p></td><td colspan="1" rowspan="1"><p>The number of message the consumer will <a shape="rect" href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch</a>.&#160; <strong>Removed in v1.7.0 use connection prefetch policy instead.</strong></p></td></tr><tr><td colspan="1" rowspan="1"><p>consumer.maximumPendingMessageLimit</p></td><td colspan="1" rowspan="1"><p>0</p></td><td colspan="1" rowspan="1"><p>Use to control if messages are dropped if a <a shape="rect" href="http://activemq.apache.org/slow-consumer-handling.html">slow consumer</a> situation exists.</p></td></tr><tr><td colspan="1" rowspan="1"><p>consumer.noLocal</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Same as the noLocal flag on a Topic consumer. Exposed here so that it can be used with a queue.</p></td></tr><tr><td colspan="1" rowspan="1"><p>consumer.dispatchAsync</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Should the broker <a shape="rect" href="http://activemq.apache.org/consumer-dispatch-async.html">dispatch messages asynchronously</a> to the consumer.</p></td></tr><tr><td colspan="1" rowspan="1"><p>consumer.retroactive</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Is this a <a shape="rect" href="http://activemq.apache.org/retroactive-consumer.html">Retroactive Consumer</a>.</p></td></tr><tr><td colspan="1" rowspan="1"><p>consumer.selector</p></td><td colspan="1" rowspan="1"><p>null</p></td><td colspan="1" rowspan="1"><p>JMS Selector used with the consumer.</p></td></tr><tr><td colspan="1" rowspan="1"><p>consumer.exclusive</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Is this an <a shape="rect" href="http://activemq.apache.org/exclusive-consumer.html">Exclusive Consumer</a>.</p></td></tr><tr><td colspan="1" rowspan="1"><p>consumer.priority</p></td><td colspan="1" rowspan="1"><p>0</p></td><td colspan="1" rowspan="1"><p>Allows you to configure a <a shape="rect" href="http://activemq.apache.org/consumer-priority.html">Consumer Priority</a>.</p></td></tr></tbody></table><h4><strong>OpenWire-only Options</strong></h4><table><tbody><tr><th colspan="1" rowspan="1"><p>Option Name</p></th><th colspan="1" rowspan="1"><p>Default</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>consumer.browser</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>consumer.networkSubscription</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>consumer.optimizedAcknowledge</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Enables an optimised acknowledgement mode where messages are acknowledged in batches rather than individually. Alternatively, you could use Session.DUPS_OK_ACKNOWLEDGE acknowledgement mode for the consumers which can often be faster. <strong>WARNING</strong> enabling this issue could cause some issues with auto-acknowledgement on reconnection</p></td></tr><tr><td colspan="1" rowspan="1"><p>consumer.noRangeAcks</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>consumer.retroactive</p></td><td colspan="1" rowspan="1"><p>false</p></td><td colspan="1" rowspan="1"><p>Sets whether or not retroactive consumers are enabled. Retroactive consumers allow non-durable topic subscribers to receive old messages that were published before the non-durable subscriber started.</p></td></tr></tbody></table></div>

