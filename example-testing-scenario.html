<div class="wiki-content maincontent"><h2 id="ExampleTestingScenario-ActiveMQPerformanceModule">ActiveMQ Performance Module</h2>

<ul><li><a shape="rect" href="activemq-performance-module-users-manual.html">Users Manual</a></li></ul>


<h2 id="ExampleTestingScenario-ExampleTestingScenario">Example Testing Scenario</h2>

<p>This page gives a simple example of the kinds of thing we wanna do.</p>

<p>Assuming that all the test code is within a single Maven POM for now (e.g. activemq-integration-test version 4.0) which will deal with all the classpath issues.</p>

<p>We'll try describe the different ways this could work and give each implementation style a name so we can start revving different ways to solve this...</p>

<h3 id="ExampleTestingScenario-Headlessbuild">Headless build</h3>

<p>In this version there is no 'controller'; each build is considered to be a totally separate build.</p>

<p>Each build knows what to do; each test case generates an XML file which becomes a named deployment artifact.</p>

<p>e.g. imagine the following builds (which are really just running Java executables within a POM for classpath)</p>
<div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p> Box </p></th><th colspan="1" rowspan="1" class="confluenceTh"><p> Description </p></th><th colspan="1" rowspan="1" class="confluenceTh"><p> Command line </p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p> hostB </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> Broker </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> java org.apache.activemq.broker.console.Main tcp://$hostA:61616 </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p> hostC </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> Consumer </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> java org.apache.activemq.test.ConsumerMain --message-count=5000 --queue=true --destination=org.foo.bar tcp://$hostA:61616 </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p> hostD </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> Producer </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> java org.apache.activemq.test.ProducerMain --message-count=5000 --queue=true --destination=org.foo.bar tcp://$hostA:61616 </p></td></tr></tbody></table></div>

<p>In the above example - each build has to kinda wait for other things to start up to some time period. e.g. the producer and consumer wanna keep around for say 5 minutes trying to connect to the broker as they can be started in any order.</p>

<p>Ideally we might wanna run this as 3 maven commands as follows...</p>
<div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
mvn activemq:broker
mvn activemq:perf-producer -Dmessage-count=5000 -Dqueue=true -Ddestination=org.foo.bar -Durl=tcp://$hostA:61616
mvn activemq:perf-consumer -Dmessage-count=5000 -Dqueue=true -Ddestination=org.foo.bar -Durl=tcp://$hostA:61616
</pre>
</div></div>

<h3 id="ExampleTestingScenario-Controllerbuild">Controller build</h3>

<p>The idea with the controller version is one of the tests (which is spun off first to try help) tries to coordinate among the test nodes.</p>

<p>e.g. we could spin the controller first...</p>
<div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p> Box </p></th><th colspan="1" rowspan="1" class="confluenceTh"><p> Description </p></th><th colspan="1" rowspan="1" class="confluenceTh"><p> Command line </p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p> hostA </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> Controller </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> mvn test </p></td></tr></tbody></table></div>

<p>Then the test case fires off these processes while communicating with them...</p>
<div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p> Box </p></th><th colspan="1" rowspan="1" class="confluenceTh"><p> Description </p></th><th colspan="1" rowspan="1" class="confluenceTh"><p> Command line </p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p> hostB </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> Broker </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> java org.apache.activemq.broker.console.Main tcp://$hostA:61616 </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p> hostC </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> Consumer </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> java org.apache.activemq.test.ConsumerMain --message-count=5000 --queue=true --destination=org.foo.bar tcp://$hostA:61616 </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p> hostD </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> Producer </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> java org.apache.activemq.test.ProducerMain --message-count=5000 --queue=true --destination=org.foo.bar tcp://$hostA:61616 </p></td></tr></tbody></table></div>


<h3 id="ExampleTestingScenario-Controllerfactorybuild">Controller factory build</h3>

<p>Fairly soon we're gonna have tons of builds firing off. We may want a single project to build with a raft of different test suites. Each single distributed integration/system/performance test might have many sub-builds (processes) to run.</p>

<p>So we might want to run a single JUnit test case which fires off different remote builds/processes.</p>

<p>e.g.</p>
<div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
public class PerformanceTestSuite {
   public void testSmallMessages() {
   	  buildQueue.start("broker", "");
   	  buildQueue.start("consumer", "--messageCount=1000");
   	  buildQueue.start("producer", "--messageCount=1000");
   	  buildQueue.join(5 * MINUTES);
   }

   public void testLargeMessages() {
   	  buildQueue.start("broker", "");
   	  buildQueue.start("consumer", "--messageCount=1000 --messageSize=1M");
   	  buildQueue.start("producer", "--messageCount=1000 --messageSize=1M");
   	  buildQueue.join(10 * MINUTES);
   }
}
</pre>
</div></div>
<p>So these 2 test cases in JUnit in the controller build will each start 3 separate remote builds on the queue and wait for them to complete - or terminate them </p></div>

