<div class="wiki-content maincontent"><p><a shape="rect" href="slow-consumers.html">Slow Consumers</a> can cause problems on non-durable topics since they can force the broker to keep old messages in RAM which once it fills up, forces the broker to slow down producers, causing the fast consumers to be slowed down. One option we could implement in the future is spooling to disk - but then spooling to disk could slow down the fast consumers too.</p><p>Currently we have a strategy that lets you configure the maximum number of matched messages the broker will keep around for a consumer in addition to its prefetch buffer. Once this maximum is reached, as new messages come in, older messages are discarded. This allows you to keep the RAM for current messages and keep sending messages to a slow consumer but to discard old messages.</p><h2 id="SlowConsumerHandling-PendingMessageLimitStrategy">Pending Message Limit Strategy</h2><p>You can configure the&#160;<strong><code>PendingMessageLimitStrategy</code></strong> implementation class on the destination map so that different regions of your topic namespace can have different strategies for dealing with slow consumers. For example you may want to use this strategy for prices which are very high volume but for orders and trades which are lower volume you might not wish to discard old messages.</p><p>The strategy calculates the maximum number of pending messages to be kept in RAM for a consumer (above its prefetch size). A value of zero means keep no messages around other than the prefetch amount. A value greater than zero will keep up to that amount of messages around, discarding the older messages as new messages come in. A value of&#160;<strong><code>-1</code></strong> disables the discarding of messages.</p><p>There are currently two different implementations of the strategy:</p><ul><li><strong><code>ConstantPendingMessageLimitStrategy</code></strong></li><li><strong><code>PrefetchRatePendingMessageLimitStrategy</code></strong></li></ul><h3 id="SlowConsumerHandling-ConstantPendingMessageLimitStrategy">ConstantPendingMessageLimitStrategy</h3><p>This strategy uses a constant limit for all consumers (above their prefetch size).</p><p>Example:</p><parameter ac:name="language">xml</parameter><plain-text-body>&lt;constantPendingMessageLimitStrategy limit="50"/&gt;
</plain-text-body><h3 id="SlowConsumerHandling-PrefetchRatePendingMessageLimitStrategy">PrefetchRatePendingMessageLimitStrategy</h3><p>This strategy calculates the maximum number of pending messages using a multiplier of the consumers prefetch size. So you could for example keep around 2.5 times the prefetch count for each consumer.</p><parameter ac:name="language">xml</parameter><plain-text-body>&lt;prefetchRatePendingMessageLimitStrategy multiplier="2.5"/&gt;
</plain-text-body><h3 id="SlowConsumerHandling-UsingthePrefetchPolicytoConfiguretheLimit">Using the Prefetch Policy to Configure the Limit</h3><p>The JMS Client has a <a shape="rect" href="what-is-the-prefetch-limit-for.html">prefetch policy</a> you can use to configure the various prefetch limits for persistent and non persistent queues and topics. The prefetch policy also allows you to specify the&#160;<strong><code>maximumPendingMessageLimit</code></strong> on a per connection/consumer basis. One minor difference with configuring this value; to simplify operation with non-JMS clients such as with <a shape="rect" href="openwire.html">OpenWire</a> the value of zero is ignored; so the lowest value you can configure is <strong><code>1</code></strong>.</p><h3 id="SlowConsumerHandling-ConfiguringtheEvictionPolicy">Configuring the Eviction Policy</h3><p>We have a&#160;<strong><code>MessageEvictionStrategy</code></strong> which is used to decide which message should be evicted on a slow consumer. The default implementation is:</p><parameter ac:name="language">xml</parameter><plain-text-body>&lt;oldestMessageEvictionStrategy/&gt;
</plain-text-body><p>However, you can write your own to use some application specific way of choosing messages for eviction. For example, if you are sending market data price updates you may wish to find an older price value, which might not be the oldest message.</p><p>Example:</p><parameter ac:name="language">xml</parameter><plain-text-body>&lt;uniquePropertyMessageEvictionStrategy propertyName="STOCK"/&gt;
</plain-text-body><p>where <strong><code>propertyName</code></strong> is the JMS message property that specifies the price.</p><p>Another option could be to use the oldest message with the lowest priority message. Therefore if you have some high priority messages, evict the lower priority messages first even if they are newer.</p><parameter ac:name="language">xml</parameter><plain-text-body>&lt;oldestMessageWithLowestPriorityEvictionStrategy/&gt;
</plain-text-body><h2 id="SlowConsumerHandling-Example">Example</h2><p>The following example shows an ActiveMQ broker configuration file. Notice that for topics in the <strong><code>PRICES.&gt;</code></strong> wildcard range the&#160;<strong><code>pendingMessageLimitStrategy</code></strong> property is set to only keep around&#160;<strong><code>10</code></strong> messages for each consumer above their prefetch buffer size.</p><parameter ac:name="">xml</parameter><plain-text-body>&lt;beans xmlns="http://www.springframework.org/schema/beans" 
       xmlns:amq="http://activemq.apache.org/schema/core"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://activemq.apache.org/schema/core
                          &#160;http://activemq.apache.org/schema/core/activemq-core.xsd"&gt;
                           
  &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"/&gt;
  
  &lt;broker xmlns="http://activemq.apache.org/schema/core" 
          persistent="false" 
          brokerName="${brokername}"&gt;
          
    &lt;!--  lets define the dispatch policy --&gt;
    &lt;destinationPolicy&gt;
      &lt;policyMap&gt;
        &lt;policyEntries&gt;

          &lt;policyEntry topic="FOO.&gt;"&gt;
            &lt;dispatchPolicy&gt;
              &lt;roundRobinDispatchPolicy/&gt;
            &lt;/dispatchPolicy&gt;
            &lt;subscriptionRecoveryPolicy&gt;
              &lt;lastImageSubscriptionRecoveryPolicy/&gt;
            &lt;/subscriptionRecoveryPolicy&gt;
          &lt;/policyEntry&gt;
          
          &lt;policyEntry topic="ORDERS.&gt;"&gt;
            &lt;dispatchPolicy&gt;
              &lt;strictOrderDispatchPolicy/&gt;
            &lt;/dispatchPolicy&gt;

            &lt;!--  1 minutes worth --&gt;
            &lt;subscriptionRecoveryPolicy&gt;
              &lt;timedSubscriptionRecoveryPolicy recoverDuration="60000"/&gt;
            &lt;/subscriptionRecoveryPolicy&gt;
          &lt;/policyEntry&gt;
          
          &lt;policyEntry topic="PRICES.&gt;"&gt;
            &lt;!-- lets force old messages to be discarded for slow consumers --&gt;
            &lt;pendingMessageLimitStrategy&gt;
              &lt;constantPendingMessageLimitStrategy limit="10"/&gt;
            &lt;/pendingMessageLimitStrategy&gt;

            &lt;!--  10 seconds worth --&gt;
            &lt;subscriptionRecoveryPolicy&gt;
              &lt;timedSubscriptionRecoveryPolicy recoverDuration="10000"/&gt;
            &lt;/subscriptionRecoveryPolicy&gt;
          &lt;/policyEntry&gt;
          
          &lt;policyEntry tempTopic="true" advisoryForConsumed="true"/&gt;
          &lt;policyEntry tempQueue="true" advisoryForConsumed="true"/&gt;
          
        &lt;/policyEntries&gt;
      &lt;/policyMap&gt;
    &lt;/destinationPolicy&gt;
  &lt;/broker&gt;
&lt;/beans&gt;</plain-text-body><h2 id="SlowConsumerHandling-UsageTips">Usage Tips</h2><p>&#160;</p><rich-text-body><p>It is advisable that if you know a particular consumer is going to be slow then set its prefetch size to something smaller than the fast consumers!</p><p>For example, if you know a particular server is quite slow and you have very high message rates<em> and</em> you have some very fast consumers then you might want to enable this feature and set the prefetch on the slow servers to be a <em>little</em> lower than on the fast servers.</p></rich-text-body><h3 id="SlowConsumerHandling-MonitoringtheStatusofSlowConsumers">Monitoring the Status of Slow Consumers</h3><p>You can also use a <a shape="rect" href="jmx.html">JMX</a> Console to view the statistics of the active subscriptions. This allows you to view the following statistics on a <strong><code>TopicSubscriptionViewMBean</code></strong>:</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Statistic</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Definition</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>discarded</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The count of how many messages have been discarded during the lifetime of the subscription due to it being a slow consumer</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>matched</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The current number of messages matched and to be dispatched to the subscription as soon as some capacity is available in the prefetch buffer. So a non-zero value implies that the prefetch buffer is full for this subscription</p></td></tr></tbody></table></div></div>

