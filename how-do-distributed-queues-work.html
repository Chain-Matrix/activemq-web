<div class="wiki-content maincontent"><p>There are various <a shape="rect" href="topologies.html">Topologies</a> that you can employ with ActiveMQ, where clients are connected to message brokers in various ways like</p>

<ul><li>peer based</li><li>client server</li><li>hub and spoke</li></ul>


<p>Each client communicates with a broker using some kind of <a shape="rect" href="cross-language-clients.html">client library and network protocol</a>. </p>

<p>To create distributed queues or topics we need to have the message brokers communicate with each other. There are two different types of broker to broker communication...</p>

<h2 id="Howdodistributedqueueswork-Master/SlaveforHighAvailability">Master/Slave for High Availability</h2>

<p>A <a shape="rect" href="masterslave.html">Master/Slave Cluster</a> is used for <a shape="rect" href="ha.html">HA</a>. Basically it means that all messages are replicated across each broker in the master/slave cluster. If the Master goes down, the clients can automatically failover to a slave which will have all the messages already, so each message is highly available. The Slave(s) provide a hot standby broker which will always be in sync ready to take over if the master goes away due to hardware failure etc.</p>

<p>Master/Slave works by having some form of replication; each message is owned by every broker in the logical cluster. A master/slave cluster then acts as one logical message broker which could then be connected via store and forward to other brokers (as we'll see in the next section).</p>

<h3 id="Howdodistributedqueueswork-DistributedQueuesandTopics">Distributed Queues and Topics</h3>

<p>In Master/Slave, queues and topics are all replicated between each broker in the cluster (so often to a master and maybe a single slave). So each broker in the cluster has exactly the same messages available at any time so if a master fails, clients failover to a slave and you don't loose a message.</p>

<h2 id="Howdodistributedqueueswork-Storeandforwardnetworksofbrokers">Store and forward networks of brokers</h2>

<p>A <a shape="rect" href="networks-of-brokers.html">Store and Forward Network of Brokers</a> means the messages travel from broker to broker until they reach a consumer; with each message being owned by a single broker at any point in time. When a JMS producer sends a message to a JMS consumer, it may travel through several brokers to reach its final destination. ActiveMQ uses <a shape="rect" href="consumer-priority.html">Consumer Priority</a> so that local JMS consumers are always higher priority than remote brokers in a store and forward network.</p>

<div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>Note though that a store and forward network is not a solution for message <a shape="rect" href="ha.html">HA</a>; if a broker fails in a Store and Forward network, the messages owned by that broker remain inside the broker's persistent store until the broker comes back online. If you need <a shape="rect" href="ha.html">HA</a> of messages then you need to use Master/Slave described above.</p></div></div>

<p>Store and forward is often used in large networks where producers are on one LAN and consumers are on another LAN and you wish to use a broker on each LAN as a kind of network concentrator to minimise chattiness over the WAN between them (and to minimise the number of connections required across the WAN too). Similar uses of store and forward can be found when using firewalls or SSL across certain networks etc. One other use case for store and forward networks is if your OS does not support many sockets (and you can't reconfigure that) you could use a store and forward network to connect massive numbers of clients together in one logical network.</p>

<h3 id="Howdodistributedqueueswork-DistributedQueuesinStore/Forward">Distributed Queues in Store/Forward</h3>
<p>When we publish a message on a queue, it is stored in the persistent store of the broker that the publisher is communicating. Then if that broker is configured to store/foward to other brokers and clients, the broker will send it to <em>one</em> of these clients (which could be a node or a broker depending on the dispatch algorithm). This dispatch algorithm continues until the message is finally dispatched and consumed by a client.</p>

<p>At any point in time the message will only exist in one broker's store until its consumed. Note that messages are only distributed onto other brokers if there is a consumer on those brokers.</p>

<p>e.g. if we had broker A, B, C and a publisher on a queue on A. If we have consumers on the queue on A and B then messages for the queue will be spread across both brokers A and B; some messages going to B, some being consumed on A, none going to C. If a consumer on the queue starts <br clear="none">
on C, then messages will flow there too. If the consumer stops then no more messages will be dispatched to C.</p>

<h2 id="Howdodistributedqueueswork-DistributedTopicsinStore/Forward">Distributed Topics in Store/Forward</h2>
<p>For topics the above algorithm is followed except, every interested client receives a copy of the message - plus ActiveMQ will check for loops (to avoid a message flowing infinitely around a ring of brokers).</p>

<h3 id="Howdodistributedqueueswork-SeeAlso">See Also</h3>

<ul><li><a shape="rect" href="how-do-i-configure-distributed-queues-or-topics.html">How do I configure distributed queues or topics</a></li><li><a shape="rect" href="masterslave.html">MasterSlave</a></li><li><a shape="rect" href="networks-of-brokers.html">Networks of Brokers</a></li></ul></div>

