<div class="wiki-content maincontent"><p>ActiveMQ implements a RESTful API to messaging which allows any web capable device to publish or consume messages using a regular HTTP POST or GET.</p><p>If you are interested in messaging directly from web browsers you might wanna check out our <link><page ri:content-title="Ajax"></page></link> or <link><page ri:content-title="WebSockets"></page></link> support or try <link><page ri:content-title="Web Samples"></page><plain-text-link-body>running the REST examples</plain-text-link-body></link></p><h2>Mapping of REST to JMS</h2><p>To publish a message use a HTTP POST. To consume a message use HTTP DELETE or GET.</p><p>ActiveMQ has a Servlet that takes care of the integration between HTTP and the ActiveMQ dispatcher.</p><p><span style="color: rgb(255,153,0);">NOTE: The example below requires servlet mapping on the URL. For posting without the servlet mapping, see examples further down.</span></p><p>You can map a URI to the servlet and then use the relative part of the URI as the topic or queue name. e.g. you could HTTP POST to</p><structured-macro ac:macro-id="c3e31109-4566-4337-a87f-0d4e80212900" ac:name="code" ac:schema-version="1"><plain-text-body>http://www.acme.com/orders/input
</plain-text-body></structured-macro><p>which would publish the contents of the HTTP POST to the orders.input queue on JMS.&#160;</p><p>Similarly you could perform a HTTP DELETE GET on the above URL to read from the same queue. In this case we will map the MessageServlet from ActiveMQ to the URI</p><structured-macro ac:macro-id="ce9bcef9-c5d4-4aba-b407-70cc33320dcf" ac:name="code" ac:schema-version="1"><plain-text-body>http://www.acme.com/queue
</plain-text-body></structured-macro><p>and configure it to accept the URI as a queue destination. We can do similar things to support topic destinations too.</p><p>We can use the HTTP session to denote a unique publisher or consumer.</p><p>Note that strict REST requires that GET be a read only operation; so strictly speaking we should not use GET to allow folks to consume messages. Though we allow this as it simplifies HTTP/DHTML/Ajax integration somewhat.</p><p>For a more cleaner mapping of a simple transfer protocol to different languages, you might wish to take a look at <link><page ri:content-title="Stomp"></page></link>.</p><h2>Default configuration</h2><p>Until version 5.8, REST API was part of the <link><page ri:content-title="Web Samples"></page></link> and was mapped to <a shape="rect" class="external-link" href="http://localhost:8161/demo/message" rel="nofollow">http://localhost:8161/demo/message</a> url. From 5.8 onwards, the API is available by default at <a shape="rect" class="external-link" href="http://localhost:8161/api/message" rel="nofollow">http://localhost:8161/api/message</a> url. Also, starting with 5.8, web server is secured by default (see <link><page ri:content-title="Web Console"></page></link> for more information), so have that in mind when trying to use it. Examples below will assume new api location and secured web server.</p><h3>Producing</h3><p>You can produce by sending a POST request to the server, like</p><structured-macro ac:macro-id="15cc401b-06c0-41d8-9570-0e1ebb7c8104" ac:name="code" ac:schema-version="1"><plain-text-body>curl -u admin:admin -d "body=message" http://localhost:8161/api/message/TEST?type=queue</plain-text-body></structured-macro><p>&#160;</p><p><span style="color: rgb(255,153,0);">NOTE: If&#160;no type parameter is specified, the default is to create a &#160;topic. To change the default to queue,&#160;initialize &#160;the servlet &#160;with an init param&#160;in the&#160;<code>webapps/demo/WEB-INF/web.xml</code></span></p><p><span style="color: rgb(255,153,0);">As shown below:</span></p><structured-macro ac:macro-id="755e25dd-23f3-47cf-911a-e9ac921d3479" ac:name="code" ac:schema-version="1"><plain-text-body>&lt;servlet&gt;
  &lt;servlet-name&gt;MessageServlet&lt;/servlet-name&gt;  
  &lt;servlet-class&gt;org.apache.activemq.web.MessageServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;init-param&gt;
     &lt;param-name&gt;topic&lt;/param-name&gt;
     &lt;param-value&gt;false&lt;/param-value&gt;
  &lt;/init-param&gt;
&lt;/servlet&gt;</plain-text-body></structured-macro><h4 class="p1"><span class="s1">Alternate Producing Syntax</span></h4><p class="p1"><span class="s1">An alternative syntax for posting is supported, using the destination URL-encoded parameter; here are some examples:</span>&#160;</p><structured-macro ac:macro-id="9dcfc8f1-019b-4f13-8277-ae4e80d218c3" ac:name="code" ac:schema-version="1"><plain-text-body># Send to queue orders.input:
curl -XPOST -d "body=message" http://admin:admin@localhost:8161/api/message?destination=queue://orders.input
 
# Send to topic orders.input:
curl -XPOST -d "body=message" http://admin:admin@localhost:8161/api/message?destination=topic://orders.input</plain-text-body></structured-macro><h3>Timeouts</h3><p>When reading from a queue we might not have any messages. We can use a timeout query parameter to indicate how long we are prepared to wait for a message to arrive. This allows us to poll or block until a message arrives.</p><p>Couple this with HTTP 1.1 keep-alive sockets and pipeline processing we can have efficient access to JMS over HTTP.</p><p>Obviously if your client is Java then using ActiveMQ's JMS API is the fastest and most efficient way to work with the message broker; however, if you are not using Java or prefer the simplicity of HTTP then it should be fairly efficient, especially if your HTTP client supports keep-alive sockets and pipeline processing.</p><h4 class="p1"><span style="font-size: 16.0px;line-height: 1.5625;">Consuming</span></h4><p>When consuming messages using the REST API, you have to keep session alive between GET requests, or you'll create a separate consumer for every request and due to prefetch limit your succeeding call will hang.</p><p>For example, you can use <code>wget</code> to consume messages, like this:</p><structured-macro ac:macro-id="5baaa5cf-de9f-40c9-b2dc-b381c3a1fd90" ac:name="code" ac:schema-version="1"><plain-text-body>wget --user admin --password admin --save-cookies cookies.txt --load-cookies cookies.txt --keep-session-cookies  http://localhost:8161/api/message/TEST1?type=queue
</plain-text-body></structured-macro><p>Also, if you plan to have multiple consumer using REST, it's advisable to set prefetch size to 1 so all consumers have an equal chance of getting the message. You can do that by passing a special parameter to the <code>MessageServlet</code></p><structured-macro ac:macro-id="1f82d93b-8c78-407e-889b-9511337343db" ac:name="code" ac:schema-version="1"><plain-text-body>    &lt;servlet&gt;
        &lt;servlet-name&gt;MessageServlet&lt;/servlet-name&gt;       
        &lt;servlet-class&gt;org.apache.activemq.web.MessageServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
        &lt;init-param&gt;
                &lt;param-name&gt;destinationOptions&lt;/param-name&gt;
                &lt;param-value&gt;consumer.prefetchSize=1&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
</plain-text-body></structured-macro><p>in the <code>webapps/demo/WEB-INF/web.xml</code></p><h4 class="p1"><span class="s1">Alternate Consuming Syntax</span></h4><p class="p1"><span class="s1">As with producing, an alternative syntax for consuming messages is also supported, using the destination URL-encoded parameter; here are some examples:</span>&#160;</p><structured-macro ac:macro-id="6d9e1eb2-9250-41e2-a32d-2aff6a409823" ac:name="code" ac:schema-version="1"><plain-text-body># Send to queue orders.input:
curl -XGET http://admin:admin@localhost:8161/api/message?destination=queue://orders.input
 
# Send to topic orders.input:
curl -XGET http://admin:admin@localhost:8161/api/message?destination=topic://orders.input</plain-text-body></structured-macro><h4 class="p1"><span style="font-size: 16.0px;line-height: 1.5625;">Consuming without sessions</span></h4><p>Since 5.2.0 you can use <code>clientId</code> parameter to avoid storing actual JMS consumer in the request session. When using this approach, you don't need to keep sessions alive between requests, you just need to use the same <code>clientId</code> every time.</p><structured-macro ac:macro-id="fb0668ba-f67a-4c35-a437-fe63da5cd862" ac:name="code" ac:schema-version="1"><plain-text-body>wget --user admin --password admin http://localhost:8161/api/message/test?type=queue&amp;clientId=consumerA
</plain-text-body></structured-macro><p>Every such call will use the same JMS consumer and deliver messages send to it by the broker.</p><p>In 5.4.1 it's also possible to unsubscribe the client. It's done by sending a POST call with <code>clientId</code> and <code>action=unsubscribe</code> parameters to the server, like</p><structured-macro ac:macro-id="84b289a3-86fe-4d90-b463-47b67945f6ae" ac:name="code" ac:schema-version="1"><plain-text-body>http://localhost:8161/demo/message/test?clientId=consumerA&amp;action=unsubscribe</plain-text-body></structured-macro><h3>Consuming with selectors</h3><p>As of ActiveMQ 5.4.0, you can use selectors when consuming using REST protocol. To do that, just specify the appropriate header with selector. To define a selector for the consumer, you have to provide it in an appropriate HTTP header. By default selector header name is <code>selector</code>, so the following example</p><structured-macro ac:macro-id="b9c43ba1-754c-4e76-a8fd-c3723e33f690" ac:name="code" ac:schema-version="1"><plain-text-body>wget  --user admin --password admin --save-cookies cookies.txt --load-cookies cookies.txt --keep-session-cookies  --header="selector: test=2" http://localhost:8161/api/message/test?type=queue
</plain-text-body></structured-macro><p>should consume only messages that have <code>test</code> property set to <code>2</code>.</p><p>You can change the name of the selector header using the <code>org.apache.activemq.selectorName</code> Servlet context property in <code>WEB-INF/web.xml</code>, such as</p><structured-macro ac:macro-id="9e372605-8936-4880-8a8b-437846b22d91" ac:name="code" ac:schema-version="1"><plain-text-body>    &lt;context-param&gt;
        &lt;param-name&gt;org.apache.activemq.selectorName&lt;/param-name&gt;
        &lt;param-value&gt;activemq-selector&lt;/param-value&gt;
    &lt;/context-param&gt;
</plain-text-body></structured-macro><p>For more info, take a look at <a shape="rect" href="http://fisheye6.atlassian.com/browse/activemq/trunk/activemq-web-demo/src/test/java/org/apache/activemq/web/RestTest.java?r=HEAD">RestTest</a></p><h3>Consuming with One Shot Consumers</h3><p>One shot consumption allows a REST call to receive a single message and then immediately close the associated consumer.</p><p>All of the examples so far lead to the servlet creating and holding on to consumers of the destination across multiple HTTP requests. Without care, these consumers could easily lead to confusion as messages are dispatched to them but then sit unused because the consuming HTTP session, or clientId, fails to connect to continue requesting the messages. One way around that problem is the use of one-shot consumers. &#160;Simple add the&#160;<code>?oneShot=true</code> option and the consumer is removed once the consumption completes; as follows:</p><structured-macro ac:macro-id="92667124-da38-4faa-b3c5-7f664ca05963" ac:name="code" ac:schema-version="1"><plain-text-body>curl -XGET http://admin:admin@localhost:8161/api/message?destination=queue://orders.input&amp;oneShot=true</plain-text-body></structured-macro><p>Note that interrupting the call while the consumer is waiting for a message, the consumer may remain until the server times out the HTTP request, or until a message finally arrives.</p><h3>Content Types</h3><p>By default messages are sent to the consumers with <code>text/xml</code> content type. Your REST-based application may expect JSON response instead of XML one. In that case, you can configure the servlet to send responses back by adding something like this</p><structured-macro ac:macro-id="27c27645-a0fb-4875-a67a-cf5866fee82b" ac:name="code" ac:schema-version="1"><plain-text-body>    &lt;servlet&gt;
        &lt;servlet-name&gt;MessageServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.apache.activemq.web.MessageServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
        &lt;init-param&gt;
                &lt;param-name&gt;defaultContentType&lt;/param-name&gt;
                &lt;param-value&gt;application/json&lt;/param-value&gt;
        &lt;/init-param&gt; 
    &lt;/servlet&gt;
</plain-text-body></structured-macro><p>to your <code>WEB-INF/web.xml</code>.</p><p>A default content type can also be overridden using request headers. Specifying <code>xml=true</code> or <code>json=true</code> URL parameter you'll get a response with the desired content type.</p><structured-macro ac:macro-id="c2b26994-ed0e-4a69-8d75-d1ac50b78dad" ac:name="code" ac:schema-version="1"><plain-text-body>wget --user admin --password admin http://localhost:8161/api/message/TEST?type=queue\&amp;clientId=A\&amp;json=true</plain-text-body></structured-macro><h3>Security</h3><p>Since 5.7.0 release REST API can connect to the secured brokers. The API uses basic authentication header format to get username and password information.</p><p>For example, with curl you can do something like</p><structured-macro ac:macro-id="e1169b07-d531-4ff6-99be-f93af72839a9" ac:name="code" ac:schema-version="1"><plain-text-body>curl -u system:manager -d "body=message" http://localhost:8161/demo/message/TEST?type=queue</plain-text-body></structured-macro><p>Also, you might want to enable <code>ssl</code> for your connections. To do that, just uncomment SecureConnector in <code>conf/jetty.xml</code></p><structured-macro ac:macro-id="d77b0a9d-152d-468f-8269-75ce924d08c4" ac:name="code" ac:schema-version="1"><plain-text-body>                &lt;bean id="SecureConnector" class="org.eclipse.jetty.server.ssl.SslSelectChannelConnector"&gt;
                    &lt;property name="port" value="8162" /&gt;
                    &lt;property name="keystore" value="file:${activemq.conf}/broker.ks" /&gt;
                    &lt;property name="password" value="password" /&gt;
                &lt;/bean&gt;</plain-text-body></structured-macro><h2>Rest Management</h2><p>Starting with version 5.8 we provide a REST management API for the broker. Using <a shape="rect" href="http://www.jolokia.org/">Jolokia</a> JMX-HTTP bridge it's possible to access all broker metrics (like memory usage) and execute management operations (like purging queues) using REST API. By default the management API is exposed at <a shape="rect" class="external-link" href="http://localhost:8161/api/jolokia/" rel="nofollow">http://localhost:8161/api/jolokia/</a> URL. So you can for example get basic broker data with</p><structured-macro ac:macro-id="756c35b2-1331-4db0-9362-374edd630e41" ac:name="code" ac:schema-version="1"><plain-text-body>wget --user admin --password admin --auth-no-challenge http://localhost:8161/api/jolokia/read/org.apache.activemq:type=Broker,brokerName=localhost</plain-text-body></structured-macro><p>or to be more specific, total consumer count with</p><structured-macro ac:macro-id="a67c2a02-e85f-4542-a10f-920558715997" ac:name="code" ac:schema-version="1"><plain-text-body>wget --user admin --password admin --auth-no-challenge http://localhost:8161/api/jolokia/read/org.apache.activemq:type=Broker,brokerName=localhost/TotalConsumerCount</plain-text-body></structured-macro><p>For more information on Jolokia protocol, see its reference manual. An API like this makes it easy to script monitoring and management operations against the broker, see also&#160;<link><page ri:content-title="How can I monitor ActiveMQ"></page></link>?</p><h2>Gotcha's and other trivia</h2><ol><li>Missing "body" parameter</li></ol><p style="margin-left: 90.0px;">In the curl POST examples above, the use of "body=..." is critical. If this is not specified in front of the message body contents, the web servlet will attempt to read the body from the request (rather than from the -d parameter), and this will result in the following exception:</p><structured-macro ac:macro-id="4d227c07-3d94-4e1d-b1d2-ccffa88b5fc8" ac:name="code" ac:schema-version="1"><plain-text-body>java.lang.IllegalStateException: STREAMED
at org.eclipse.jetty.server.Request.getReader(Request.java:898)
at org.apache.activemq.web.MessageServletSupport.getPostedMessageBody(MessageServletSupport.java:347)
at org.apache.activemq.web.MessageServlet.doPost(MessageServlet.java:126)
...</plain-text-body></structured-macro><p style="margin-left: 90.0px;">However, one option in this case would be to specify the content type explicitly:</p><structured-macro ac:macro-id="75b549c1-79fa-4b39-bd8e-855732a103b3" ac:name="code" ac:schema-version="1"><plain-text-body>curl -u admin:admin -d "hello world $(date)" -H "Content-Type: text/plain" -XPOST http://localhost:8161/api/message?destination=queue://abc.def</plain-text-body></structured-macro></div>

