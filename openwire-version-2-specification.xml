<div class="wiki-content maincontent"><structured-macro ac:macro-id="e57eb113-a915-4ebf-8acb-20267863ecd8" ac:name="warning" ac:schema-version="1"><parameter ac:name="title">OpenWire Version 2 is not the latest version.</parameter><rich-text-body><p>This article references OpenWire V2 which is no longer the latest version. The formatting and encoding rules in this article are still valid for later OpenWire versions, but later versions define additional fields in the OpenWire commands. The default settings shown in this article may not reflect the current defaults, see <link><page ri:content-title="Configuring Wire Formats"></page><plain-text-link-body>this page</plain-text-link-body></link> for the latest default OpenWire settings.</p></rich-text-body></structured-macro><h2>Overview</h2><p>OpenWire is used to marshal objects to byte arrays and back. We will refer to the marshaled objects as commands.</p><p>A TCP network connection would see multiple commands back to back on the stream. Commands are not delimited in anyway and are variable sized.</p><structured-macro ac:macro-id="dcbac81c-4b75-4411-b53d-36724c440353" ac:name="code" ac:schema-version="1"><plain-text-body>+---------+  +---------+      +---------+
| command |  | command | .... | command |
+---------+  +---------+      +---------+
</plain-text-body></structured-macro><p>All data primitive types used in the encoded commands are encoded in big-endian/network byte order.</p><structured-macro ac:macro-id="36d2f345-0a5b-40c9-8c00-ef7ba01c436e" ac:name="code" ac:schema-version="1"><plain-text-body>primitive types and encoding:
             |               |               |               |               |               |               
+----------+ | +-----------+ | +-----------+ | +-----------+ | +-----------+ | +-----------+ | +-----------+ 
| byte     | | | char      | | | short     | | | int       | | | long      | | | float     | | | double    | 
+----------+ | +-----------+ | +-----------+ | +-----------+ | +-----------+ | +-----------+ | +-----------+ 
| 1 octect | | | 2 octects | | | 2 octects | | | 4 octects | | | 8 octects | | | 4 octects | | | 8 octects | 
+----------+ | +-----------+ | +-----------+ | +-----------+ | +-----------+ | +-----------+ | +-----------+ 
             |               |               |               |               |               |               
</plain-text-body></structured-macro><h2>Wire Format Negotiation</h2><p>OpenWire is an extensible in that it supports adding new encoding options while still being backward compatible with previous versions of the protocol. Every OpenWire protocol session initially starts with all encoding options turned off and at version 1 of command marshalers. An initial WIREFORMAT_INFO command is exchanged between the two nodes so that additional encoding features can be enabled. If both sides request an encoding feature to be enabled then it will be enabled. The command marshalers used will be the highest version that they both support.</p><structured-macro ac:macro-id="3d379f79-d70f-490d-a9f8-67ece215e6ea" ac:name="code" ac:schema-version="1"><plain-text-body>+-------------------------+ +---------+  +---------+      +---------+
| WIREFORMAT_INFO command | | command |  | command | .... | command |
+-------------------------+ +---------+  +---------+      +---------+
</plain-text-body></structured-macro><h2>Command Encoding</h2><p>Every command is encoded as follows:</p><structured-macro ac:macro-id="60b03de1-6016-4994-bce7-63e7e51f772e" ac:name="code" ac:schema-version="1"><plain-text-body>command encoding:
[=If SizePrefixDisabled =] 
[ option is not enabled. ]
[ +------+               ] +------+-------------------------+
[ | size |               ] | type | command-specific-fields |
[ +------+               ] +------+-------------------------+
[ | int  |               ] | byte | (size-1) octects        |
[ +------+               ] +------+-------------------------+
[========================]
</plain-text-body></structured-macro><table><tbody><tr><th colspan="1" rowspan="1"><p>Field</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>size</p></td><td colspan="1" rowspan="1"><p>Holds how many subsequent bytes are in the the command</p></td></tr><tr><td colspan="1" rowspan="1"><p>type</p></td><td colspan="1" rowspan="1"><p>Command type identifier</p></td></tr><tr><td colspan="1" rowspan="1"><p>command-specific-fields</p></td><td colspan="1" rowspan="1"><p>The data for the command. It is encoding depends on the type used</p></td></tr></tbody></table><p>If a command type does not have any command specific content, then size would be 1.</p><p>Prefixing the size on every command is done to aid in non-blocking IO processing so that receiver can easily determine when a whole command has been received and can be processed. But finding out the size of command takes additional buffering on the sender size and is not needed if the receiver is doing blocking IO. If the SizePrefixDisabled option is enabled after the exchange of WIREFORMAT_INFO packets, then every subsequent command will not have the size prefixed.</p><h2>Command Types</h2><table><tbody><tr><th colspan="1" rowspan="1"><p>Type Identifier</p></th><th colspan="1" rowspan="1"><p>Command</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>1</p></td><td colspan="1" rowspan="1"><p>WIREFORMAT_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>2</p></td><td colspan="1" rowspan="1"><p>BROKER_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>3</p></td><td colspan="1" rowspan="1"><p>CONNECTION_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>4</p></td><td colspan="1" rowspan="1"><p>SESSION_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>5</p></td><td colspan="1" rowspan="1"><p>CONSUMER_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>6</p></td><td colspan="1" rowspan="1"><p>PRODUCER_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>7</p></td><td colspan="1" rowspan="1"><p>TRANSACTION_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>8</p></td><td colspan="1" rowspan="1"><p>DESTINATION_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>9</p></td><td colspan="1" rowspan="1"><p>REMOVE_SUBSCRIPTION_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>10</p></td><td colspan="1" rowspan="1"><p>KEEP_ALIVE_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>11</p></td><td colspan="1" rowspan="1"><p>SHUTDOWN_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>12</p></td><td colspan="1" rowspan="1"><p>REMOVE_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>14</p></td><td colspan="1" rowspan="1"><p>CONTROL_COMMAND</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>15</p></td><td colspan="1" rowspan="1"><p>FLUSH_COMMAND</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>16</p></td><td colspan="1" rowspan="1"><p>CONNECTION_ERROR</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>17</p></td><td colspan="1" rowspan="1"><p>CONSUMER_CONTROL</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>18</p></td><td colspan="1" rowspan="1"><p>CONNECTION_CONTROL</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>21</p></td><td colspan="1" rowspan="1"><p>MESSAGE_DISPATCH</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>22</p></td><td colspan="1" rowspan="1"><p>MESSAGE_ACK</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>23</p></td><td colspan="1" rowspan="1"><p>ACTIVEMQ_MESSAGE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>24</p></td><td colspan="1" rowspan="1"><p>ACTIVEMQ_BYTES_MESSAGE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>25</p></td><td colspan="1" rowspan="1"><p>ACTIVEMQ_MAP_MESSAGE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>26</p></td><td colspan="1" rowspan="1"><p>ACTIVEMQ_OBJECT_MESSAGE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>27</p></td><td colspan="1" rowspan="1"><p>ACTIVEMQ_STREAM_MESSAGE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>28</p></td><td colspan="1" rowspan="1"><p>ACTIVEMQ_TEXT_MESSAGE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>30</p></td><td colspan="1" rowspan="1"><p>RESPONSE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>31</p></td><td colspan="1" rowspan="1"><p>EXCEPTION_RESPONSE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>32</p></td><td colspan="1" rowspan="1"><p>DATA_RESPONSE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>33</p></td><td colspan="1" rowspan="1"><p>DATA_ARRAY_RESPONSE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>34</p></td><td colspan="1" rowspan="1"><p>INTEGER_RESPONSE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>40</p></td><td colspan="1" rowspan="1"><p>DISCOVERY_EVENT</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>50</p></td><td colspan="1" rowspan="1"><p>JOURNAL_ACK</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>52</p></td><td colspan="1" rowspan="1"><p>JOURNAL_REMOVE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>53</p></td><td colspan="1" rowspan="1"><p>JOURNAL_TRACE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>54</p></td><td colspan="1" rowspan="1"><p>JOURNAL_TRANSACTION</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>55</p></td><td colspan="1" rowspan="1"><p>DURABLE_SUBSCRIPTION_INFO</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>60</p></td><td colspan="1" rowspan="1"><p>PARTIAL_COMMAND</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>61</p></td><td colspan="1" rowspan="1"><p>PARTIAL_LAST_COMMAND</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>65</p></td><td colspan="1" rowspan="1"><p>REPLAY</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>70</p></td><td colspan="1" rowspan="1"><p>BYTE_TYPE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>71</p></td><td colspan="1" rowspan="1"><p>CHAR_TYPE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>72</p></td><td colspan="1" rowspan="1"><p>SHORT_TYPE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>73</p></td><td colspan="1" rowspan="1"><p>INTEGER_TYPE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>74</p></td><td colspan="1" rowspan="1"><p>LONG_TYPE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>75</p></td><td colspan="1" rowspan="1"><p>DOUBLE_TYPE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>76</p></td><td colspan="1" rowspan="1"><p>FLOAT_TYPE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>77</p></td><td colspan="1" rowspan="1"><p>STRING_TYPE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>78</p></td><td colspan="1" rowspan="1"><p>BOOLEAN_TYPE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>79</p></td><td colspan="1" rowspan="1"><p>BYTE_ARRAY_TYPE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>90</p></td><td colspan="1" rowspan="1"><p>MESSAGE_DISPATCH_NOTIFICATION</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>91</p></td><td colspan="1" rowspan="1"><p>NETWORK_BRIDGE_FILTER</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>100</p></td><td colspan="1" rowspan="1"><p>ACTIVEMQ_QUEUE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>101</p></td><td colspan="1" rowspan="1"><p>ACTIVEMQ_TOPIC</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>102</p></td><td colspan="1" rowspan="1"><p>ACTIVEMQ_TEMP_QUEUE</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>103</p></td><td colspan="1" rowspan="1"><p>ACTIVEMQ_TEMP_TOPIC</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>110</p></td><td colspan="1" rowspan="1"><p>MESSAGE_ID</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>111</p></td><td colspan="1" rowspan="1"><p>ACTIVEMQ_LOCAL_TRANSACTION_ID</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>112</p></td><td colspan="1" rowspan="1"><p>ACTIVEMQ_XA_TRANSACTION_ID</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>120</p></td><td colspan="1" rowspan="1"><p>CONNECTION_ID</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>121</p></td><td colspan="1" rowspan="1"><p>SESSION_ID</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>122</p></td><td colspan="1" rowspan="1"><p>CONSUMER_ID</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>123</p></td><td colspan="1" rowspan="1"><p>PRODUCER_ID</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1"><p>124</p></td><td colspan="1" rowspan="1"><p>BROKER_ID</p></td><td colspan="1" rowspan="1"><p>&#160;</p></td></tr></tbody></table><h3>Command Field Encoding</h3><p>All OpenWire commands use the same algorithm when encoding their fields. The algorithm restricts commands to use fields that are of the following type:</p><ul><li>Java primitive types</li><li>String</li><li>Byte Arrays</li><li>N Sized Byte Arrays</li><li>Throwable</li><li>Nested OpenWire commands</li><li>Nested OpenWire command arrays</li><li>Cached Nested OpenWire commands</li></ul><p>Notice that OpenWire commands can nest other OpenWire commands in it's fields. Care must be taken that only acyclic graphs of commands are marshaled.</p><h4>String Type Encoding</h4><p>Strings fields may be null. If it is null then it encodes to a single "0" byte.</p><structured-macro ac:macro-id="d6a2ba0b-657b-445d-9c5d-75ae56cb843b" ac:name="code" ac:schema-version="1"><plain-text-body>string encoding:
             [=If not-null is 1===========]
+----------+ [ +-------+----------------+ ]
| not-null | [ | size  | encoded-string | ]
+----------+ [ +-------+----------------+ ]
| byte     | [ | short | size octects   | ]
+----------+ [ +-------+----------------+ ]
             [============================]
</plain-text-body></structured-macro><table><tbody><tr><th colspan="1" rowspan="1"><p>Field</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>not-null</p></td><td colspan="1" rowspan="1"><p>1 if the string is not null, 0 if the string is null</p></td></tr><tr><td colspan="1" rowspan="1"><p>size</p></td><td colspan="1" rowspan="1"><p>The number of bytes of the UTF-8 Encoded string</p></td></tr><tr><td colspan="1" rowspan="1"><p>encoded-string</p></td><td colspan="1" rowspan="1"><p>The UTF-8 encoded form of the string</p></td></tr></tbody></table><h3>Byte Array Type Encoding</h3><p>Byte array fields may be null. If it is null then it encodes to a single "0" byte.</p><structured-macro ac:macro-id="944ceaf4-84b2-4dc5-b96e-f4c3a3af76cf" ac:name="code" ac:schema-version="1"><plain-text-body>byte-array encoding:
             [=If not-null is 1========]
+----------+ [ +------+--------------+ ]
| not-null | [ | size | data         | ]
+----------+ [ +------+--------------+ ]
| byte     | [ | int  | size octects | ]
+----------+ [ +------+--------------+ ]
             [=========================]
</plain-text-body></structured-macro><table><tbody><tr><th colspan="1" rowspan="1"><p>Field</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>not-null</p></td><td colspan="1" rowspan="1"><p>1 if the byte array is not null, 0 if it is null</p></td></tr><tr><td colspan="1" rowspan="1"><p>size</p></td><td colspan="1" rowspan="1"><p>The number of bytes in the byte array</p></td></tr><tr><td colspan="1" rowspan="1"><p>data</p></td><td colspan="1" rowspan="1"><p>The data of the byte array</p></td></tr></tbody></table><h3>N Sized Byte Array Type Encoding</h3><p>Fixed Size Byte array fields may NOT be null and their length must be N length. Used for byte arrays that are always a fixed size.</p><structured-macro ac:macro-id="dd7334a1-9fca-4ec6-aae8-69e9dd360d4d" ac:name="code" ac:schema-version="1"><plain-text-body>N-sized-byte-array encoding:
+-----------+
| data      |
+-----------+
| N octects |
+-----------+
</plain-text-body></structured-macro><table><tbody><tr><th colspan="1" rowspan="1"><p>Field</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>data</p></td><td colspan="1" rowspan="1"><p>The data of the byte array</p></td></tr></tbody></table><h3>Throwable Type Encoding</h3><p>Throwable fields may be null. If it is null then it encodes to a single "0" byte.</p><structured-macro ac:macro-id="217ef4df-fac6-467f-911c-09ae8f011345" ac:name="code" ac:schema-version="1"><plain-text-body>throwable encoding:
             [=If not-null is 1===========================================================================]
             [                               [=If StackTraceEnabled option is enabled.==================] ]
             [                               [             [=Repeated size times======================] ] ]
+----------+ [ +----------------+---------+  [ +-------+ [ +--------+--------+--------+-------------+ ] ] ]
| not-null | [ | exception-name | message |  [ | size  | [ | class  | method | file   | line-number | ] ] ]
+----------+ [ +----------------+---------+  [ +-------+ [ +--------+--------+--------+-------------+ ] ] ]
| byte     | [ | string         | string  |  [ | short | [ | string | string | string | int         | ] ] ]
+----------+ [ +----------------+---------+  [ +-------+ [ +--------+--------+--------+-------------+ ] ] ]
             [                               [           [============================================] ] ]
             [                               [==========================================================] ]
             [============================================================================================]
</plain-text-body></structured-macro><table><tbody><tr><th colspan="1" rowspan="1"><p>Field</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>not-null</p></td><td colspan="1" rowspan="1"><p>1 if the Throwable not null, 0 if the Throwable is null</p></td></tr><tr><td colspan="1" rowspan="1"><p>exception-name</p></td><td colspan="1" rowspan="1"><p>The class name of the exception</p></td></tr><tr><td colspan="1" rowspan="1"><p>message</p></td><td colspan="1" rowspan="1"><p>The exception message</p></td></tr><tr><td colspan="1" rowspan="1"><p>size</p></td><td colspan="1" rowspan="1"><p>The number of stack frames in the stack trace</p></td></tr><tr><td colspan="1" rowspan="1"><p>class</p></td><td colspan="1" rowspan="1"><p>The name of the class in a stack frame</p></td></tr><tr><td colspan="1" rowspan="1"><p>method</p></td><td colspan="1" rowspan="1"><p>The name of the method in a stack frame</p></td></tr><tr><td colspan="1" rowspan="1"><p>file</p></td><td colspan="1" rowspan="1"><p>The name of the file in a stack frame</p></td></tr><tr><td colspan="1" rowspan="1"><p>line-number</p></td><td colspan="1" rowspan="1"><p>The line number in a stack frame</p></td></tr></tbody></table><p>If the StackTraceEnabled encoding option is enabled after the exchange of WIREFORMAT_INFO packets, then every Throwable filed will have stack trace data appended to it.</p><h3>Nested Command Type Encoding</h3><p>Nested command fields may be null. If it is null then it encodes to a single "0" byte.</p><structured-macro ac:macro-id="931597fa-9ac8-48c5-b243-5c3a3ff54511" ac:name="code" ac:schema-version="1"><plain-text-body>nested-object encoding:
             [=If not-null is 1===================]
+----------+ [ +------+-------------------------+ ]
| not-null | [ | type | command-specific-fields | ]
+----------+ [ +------+-------------------------+ ]
| byte     | [ | byte | variable sized          | ]
+----------+ [ +------+-------------------------+ ]
             [====================================]
</plain-text-body></structured-macro><table><tbody><tr><th colspan="1" rowspan="1"><p>Field</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>not-null</p></td><td colspan="1" rowspan="1"><p>1 if the Throwable not null, 0 if the Throwable is null</p></td></tr><tr><td colspan="1" rowspan="1"><p>type</p></td><td colspan="1" rowspan="1"><p>Command type identifier</p></td></tr><tr><td colspan="1" rowspan="1"><p>command-specific-fields</p></td><td colspan="1" rowspan="1"><p>The data for the command. It is encoding depends on the type used</p></td></tr></tbody></table><h3>Cached Nested Command Type Encoding</h3><p>Nested Command types can be cached so that subsequent marshaling operations of the same object result in a smaller on the wire size. By default the CacheEnabled option is not enabled and therefore standard nested-object encoding is used.</p><structured-macro ac:macro-id="bed186ab-21d4-4339-ae3c-b1d0e7d0ec19" ac:name="code" ac:schema-version="1"><plain-text-body>cached-object-encoding:
[=If CacheEnabled option is enabled=====================]
[                       [=If new-value is 1===========] ]
[ +-----------+-------+ [ +-------------------------+ ] ]
[ | new-value | key   | [ | command-specific-fields | ] ]
[ +-----------+-------+ [ +-------------------------+ ] ]
[ | byte      | short | [ | nested-object           | ] ]
[ +-----------+-------+ [ +-------------------------+ ] ]
[                       [=============================] ]
[=====================================================] ]

[=If CacheEnabled option is disabled =]
[ +-------------------------+         ]
[ | command-specific-fields |         ]
[ +-------------------------+         ]
[ | nested-object           |         ]
[ +-------------------------+         ]
[=====================================]
</plain-text-body></structured-macro><table><tbody><tr><th colspan="1" rowspan="1"><p>Field</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>new-value</p></td><td colspan="1" rowspan="1"><p>1 if the value is not in the cache, 0 if it already is in the cache</p></td></tr><tr><td colspan="1" rowspan="1"><p>key</p></td><td colspan="1" rowspan="1"><p>Key used to identify the value in the cache</p></td></tr><tr><td colspan="1" rowspan="1"><p>command-specific-fields</p></td><td colspan="1" rowspan="1"><p>The data for the command. It is encoding depends on the type used</p></td></tr></tbody></table><h2>Loose Encoding</h2><p>The default encoding explained so far is called "loose encoding" and is the default encoding used when OpenWire if first initialized. Loose encoding is simple to implement does not add much CPU overhead to the marshaling/unmarshaling process. It is able to marshal an object graph in single pass of the object tree.</p><h2>Tight Encoding</h2><p>Another encoding option is supported by OpenWire which is called TightEncoding. When tight encoding is used, it uses bit streams to marshal all the boolean values that would have taken up a byte in loose encoding to a bit in the bit stream. To build the bit stream 2 passes through the object graph are taken so this is more CPU intensive marshaling process but it produces a smaller on the wire size.</p></div>

