<div class="wiki-content maincontent"><p>Multiple different policies can be applied per destination (queue or topic), or using wildcard notation to apply to a hierarchy of queues or topics, making it possible, therefore, to configure how different regions of the JMS destination space are handled.</p><p>The following properties can be applied to either topics and/or queues:</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Common Property</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Default</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>advisoryForConsumed</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Send an advisory message when a message is consumed by a client.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>advisoryForDelivery</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Send an advisory message when a message is sent to a client.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>advisoryForFastProducers</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Send an advisory message if a producer is deemed fast.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>advisoryForSlowConsumers</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Send an advisory message if a consumer is deemed slow.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>advisoryWhenFull</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Send an advisory message when a limit (memory, store, temp disk) is full.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>enableAudit</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>When&#160;<strong><code>true</code></strong> the broker will track duplicate messages. Duplicates can happen for non-persistent messages during failover.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>gcInactiveDestinations</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Garbage collect inactive destinations.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>inactiveTimoutBeforeGC</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>5000</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The timeout (in ms) after which a destination is considered inactive.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>includeBodyForAdvisory</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Includes the body of the original message that triggered the advisory as part of the&#160;<strong><code>dataStructure</code></strong> field in the advisory message (where applicable). Normally the message body is cleared.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>maxBrowsePageSize</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>400</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The maximum number of messages to page in from the store at one time for a browser.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>maxDestinations</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>-1</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>(v5.12) If <strong><code>&gt;= 0</code></strong>, sets the maximum number of destinations that can be created. This parameter is intended to limit the number of hierarchical destinations that can be created under a wildcard destination.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>maxPageSize</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>200</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The maximum number of messages to page in from the store at one time. Increase this value to improve performance for queue destination's that contain grouped messages that are consumed by multiple concurrent consumers.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>memoryLimit</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>n/a</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The memory limit (in bytes) of the destination's cursor.</p><p>This memory limit is subordinate to the system level memory limit, as specified by the&#160;<a shape="rect" href="producer-flow-control.html"><code>&lt;systemUsage&gt;/&lt;memoryUsage&gt;</code></a> <span class="confluence-link">attribute</span>. There is no default for this value; it simply acts as a child to the overall broker memory until the broker memory is exhausted.</p><p><strong>Note</strong>: when this limit is specified the destination's&#160;<strong><code>cursorMemoryHighWaterMark</code></strong> will be applied against it and not the&#160;<strong><code>&lt;systemUsage&gt;/&gt;&lt;memoryUsage&gt;</code></strong> memory limit.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>minimumMessageSize</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>1024</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>For non-serialized messages (embedded broker) - the assumed size of the message used for memory usage calculation. Serialized messages use the serialized size as the basis for the memory calculation.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>prioritizedMessages</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Persist message priority information.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>producerFlowControl</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>If <strong><code>true</code></strong> the broker will throttle (flow-control) the producer. Throttling is achieved either by withholding the producer's ACK or by raising a&#160;<strong><code>javax.jms.ResourceAllocationException</code></strong> (that's propagated back to the client) when local resources, e.g., memory and/or storage, have been exhausted.</p><p>If&#160;<strong><code>false</code></strong> excess messages will be written to the message store to prevent memory exhaustion. However, when the message store reaches capacity the producer will be throttled until resources are freed.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>slowConsumerStrategy</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Sets the strategy for handling slow consumers. See <a shape="rect" class="external-link" href="https://github.com/apache/activemq/blob/master/activemq-broker/src/main/java/org/apache/activemq/broker/region/policy/AbortSlowConsumerStrategy.java" rel="nofollow">AbortSlowConsumerStrategy.</a></p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>storeUsageHighWaterMark</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>100</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The percentage (%) threshold of the&#160;<strong><code>&lt;systemUsage&gt;/&lt;storeUsage&gt;</code></strong> store limit which when exceeded causes a producer send to block.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>useCache</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>If&#160;<strong><code>true</code></strong> persistent messages are cached for fast retrieval from store.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><span><code>usePrefetchExtension</code><br clear="none"></span></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The prefetch extension is used when a&#160;message is delivered but not ACK'ed, such that the broker can dispatch&#160;another message, e.g., <strong><code>prefetch == 0</code></strong>, the idea being that there will always be prefetch number of messages pending. It also allows a transaction batch to exceed the prefetch&#160;value.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code><span style="color: rgb(0,0,0);">sendFailIfNoSpace </span></code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code><span style="color: rgb(0,0,0);">false</span></code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><span style="color: rgb(0,0,0);">(v5.16.0) If <strong><code>true</code></strong>, will cause a send to fail with a&#160;<strong><code>javax.jms.ResourceAllocationException</code></strong> when the destination has reached is resource limits (memory or storage)</span></p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code><span style="color: rgb(0,0,0);">sendFailIfNoSpaceAfterTimeout</span></code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>0</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><span style="color: rgb(0,0,0);">(v5.16.0) If <strong><code>&gt; 0</code></strong>, will cause a send to fail with a&#160;<span style="color: rgb(0,0,0);"><strong><code>javax.jms.ResourceAllocationException</code></strong></span> when the destination resource limits (memory or storage) remain exhausted for the configured duration in milliseconds</span></p></td></tr></tbody></table></div><p>The following properties&#160;can be applied <em>only</em> to a queue:</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Queue Only Property</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Default</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>allConsumersExclusiveByDefault</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>When&#160;<strong><code>true</code></strong> all consumers will be exclusive. See <a shape="rect" href="nms/activemq-exclusive-consumers.html">ActiveMQ Exclusive Consumers</a></p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>cursorMemoryHighWaterMark</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>70</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The percentage (%) threshold applied either to the&#160;<strong><code>&lt;systemUsage&gt;/&lt;memoryUsage&gt;</code></strong> or the destination's&#160;<strong><code>memoryLimit</code></strong> (when defined) which when exceeded will cause the destination's cursor to either block or write to disk.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>consumersBeforeDispatchStarts</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>0</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>When the first consumer connects, wait for specified number of consumers before message dispatching starts.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>expireMessagesPeriod</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>30000</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The period (in ms) of checks for message expiry on queued messages.</p><p>A value of&#160;<strong><code>0</code></strong> will disable expiration checking.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>lazyDispatch</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Only page in from store the number of messages that can be dispatched at time.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>maxExpirePageSize</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>400</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The maximum number of messages to page in when periodically expiring messages.</p><p>Messages are paged in according to this setting if the number of messages in memory pending dispatch is less than this value, and there are messages in the store to page in. Messages are expired during this paging step as they are brought into memory from the store.</p><p>Once the paging process is completed, messages are expired from the list of those that are in memory and pending dispatch, then from the list of those that are in memory but not yet targeted at a subscription.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>optimizedDispatch</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Don't use a separate thread for dispatching from a Queue.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>persistJMSRedelivered</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>(v 5.10) If true, before a persistent message is dispatched by the broker for the first time, the message is rewritten to reflect the possible delivery.</p><p>This ensures the message&#160;<strong><code>JMSRedelivered</code></strong> header is a reliable indication of possible duplicate delivery.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>queuePrefetch</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>n/a</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Sets the prefetch for consumers that are using the default value.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>strictOrderDispatch</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>If&#160;<strong><code>true</code></strong> queue will not round robin consumers, but it'll use a single one until its prefetch buffer is full.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>timeBeforeDispatchStarts</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>0</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>When the first consumer connects, wait for specified time (in ms) before message dispatching starts.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>useConsumerPriority</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Use the priority of a consumer when dispatching messages from a Queue.</p></td></tr></tbody></table></div><p>The following properties&#160;can be applied <em>only</em> to a topic:</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Topic Only Property</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Default</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>advisoryForDiscardingMessages</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Send an advisory when a message is discarded from a non durable subscription.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>cursorMemoryHighWaterMark</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>70</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The percentage (%) threshold applied to the&#160;<strong><code>&lt;systemUsage&gt;/&lt;memoryUsage&gt;</code></strong> which when exceeded will cause the destination's cursor to either block or write to disk.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><span style="color: rgb(0,0,0);"><code>alwaysRetroactive</code><br clear="none"></span></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Makes all subscribers retroactive negating the need to modify the clients to enable this feature.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>durableTopicPrefetch</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>n/a</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Sets the prefetch for durable topic consumers that are using the default value.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><span style="color: rgb(0,0,0);"><code>expireMessagesPeriod</code><br clear="none"></span></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>30000</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The interval (in ms) between message expiration checks on inactive durable subscribers.</p><p><strong>Note</strong>: set to <strong><code>0</code></strong> to disable message expiration checking.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>topicPrefetch</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>n/a</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Sets the prefetch for topic consumers that are using the default value.</p></td></tr></tbody></table></div><p><span style="line-height: 1.4285715;">The following are examples of different policies that can be customized on a per destination basis:</span></p><ul><li><a shape="rect" href="dispatch-policies.html">Dispatch Policies</a></li></ul><p>An example from the demos&#160;<a shape="rect" class="external-link" href="https://git-wip-us.apache.org/repos/asf?p=activemq.git;a=blob;f=assembly/src/release/examples/conf/activemq-demo.xml;hb=HEAD">https://git-wip-us.apache.org/repos/asf?p=activemq.git;a=blob;f=assembly/src/release/examples/conf/activemq-demo.xml;hb=HEAD</a>:&#160;</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: xml; gutter: false; theme: Default" style="font-size:12px;">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:amq="http://activemq.apache.org/schema/core"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
                           http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd"&gt;
 
  &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"/&gt;
 
  &lt;broker persistent="false" 
          brokerName="${brokername}" 
          xmlns="http://activemq.apache.org/schema/core"&gt;
    
    &lt;destinationPolicy&gt;
      &lt;policyMap&gt;
        &lt;policyEntries&gt;
          &lt;policyEntry topic="FOO.&gt;"&gt;
            &lt;dispatchPolicy&gt;
              &lt;roundRobinDispatchPolicy/&gt;
            &lt;/dispatchPolicy&gt;
            &lt;subscriptionRecoveryPolicy&gt;
              &lt;lastImageSubscriptionRecoveryPolicy/&gt;
            &lt;/subscriptionRecoveryPolicy&gt;
          &lt;/policyEntry&gt;
           
          &lt;policyEntry topic="ORDERS.&gt;"&gt;
            &lt;dispatchPolicy&gt;
              &lt;strictOrderDispatchPolicy/&gt;
            &lt;/dispatchPolicy&gt;
 
            &lt;!-- Recover 1 minute's worth --&gt;
            &lt;subscriptionRecoveryPolicy&gt;
              &lt;timedSubscriptionRecoveryPolicy recoverDuration="60000"/&gt;
            &lt;/subscriptionRecoveryPolicy&gt;
          &lt;/policyEntry&gt;
     
          &lt;policyEntry topic="PRICES.&gt;"&gt;
            &lt;!-- Force pending messages to be discarded for slow consumers --&gt;
            &lt;pendingMessageLimitStrategy&gt;
              &lt;constantPendingMessageLimitStrategy limit="10"/&gt;
            &lt;/pendingMessageLimitStrategy&gt;
 
            &lt;!-- 10 seconds worth --&gt;
            &lt;subscriptionRecoveryPolicy&gt;
              &lt;timedSubscriptionRecoveryPolicy recoverDuration="10000"/&gt;
            &lt;/subscriptionRecoveryPolicy&gt;
             
          &lt;/policyEntry&gt;
          &lt;policyEntry tempTopic="true" advisoryForConsumed="true"/&gt;
          &lt;policyEntry tempQueue="true" advisoryForConsumed="true"/&gt;
        &lt;/policyEntries&gt;
      &lt;/policyMap&gt;
    &lt;/destinationPolicy&gt;
  &lt;/broker&gt;
&lt;/beans&gt;</pre>
</div></div><p>&#160;</p><p>&#160;</p></div>

